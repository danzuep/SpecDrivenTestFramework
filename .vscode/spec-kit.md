```sh
# uv tool install specify-cli --from git+https://github.com/github/spec-kit.git # --force
# uv tool update-shell
# specify check
mkdir spec-kit
cd spec-kit
specify init SpecDrivenTestFramework
cd SpecDrivenTestFramework
gh repo create --source=. --private --description "A minimal proof of concept of a replayable test framework." # --confirm
git remote add origin https://github.com/danzuep/SpecDrivenTestFramework.git; git branch -M main; git push -u origin main
```

<!-- /speckit.constitution Declare bare-minimum principles focused on code quality, modularity, simple UX, and minimal dependencies. -->
/speckit.constitution Write a concise project constitution that sets the guiding principles for this repository. Emphasize high code quality (readability, consistent style, comprehensive tests), modularity (clear separations of concern, well‑defined interfaces), simple and predictable UX for both CLI and library usage, minimal runtime dependencies favoring small well‑maintained libraries, testability (dependency injection, inversion of control, no hidden globals), and a clear versioning/backward‑compatibility policy. For each principle include a one‑sentence rationale and one short actionable rule or example a contributor should follow. Keep it actionable and suitable for inclusion in CONTRIBUTING.md.

/speckit.specify Produce a concise specification for a minimal open testing/contract framework that records API request/response pairs and replays them for regression testing. Include purpose and high‑level architecture (library + CLI), primary use cases (recording, replaying, validating, exporting fixtures), the data model for recorded events (timestamp, origin, request, response, metadata like env and version), default normalization rules for ambiguous/non‑deterministic fields and how to configure them, security/privacy considerations (sanitization, secret masking, opt‑in/opt‑out), performance/scale constraints for local demo (target: up to hundreds of recordings), configurability (JSON/YAML formats, storage layout, stubbing external calls), and error handling/failure modes (mismatched responses should produce a diff and optional auto‑update workflow). Use reasonable defaults when unspecified and explicitly list any assumptions. Acceptance: clear architecture and data model, normalization rules, security guidelines, file formats, and basic error handling; assumptions flagged.

/speckit.plan Produce a development plan and implementation blueprint for a Kotlin library + CLI that implements the specification. Include project layout (Gradle modules: core library, CLI, testing/integration, examples), module responsibilities and public interfaces (Recorder, Player, Normalizer, Storage, Serializer, CLI adapter), DI approach (Koin/Hilt or constructor+interface) with rationale, external effects pattern (interfaces for Console, HttpClient, Clock), persistence/storage choices and default file layout, and a testing strategy: unit tests for each module with example test cases and mocking approach, contract tests to validate recorded vs replayed interactions, and an integration test scenario for a local demo payment flow (step‑by‑step, test data, expected outcomes). Add CI pipeline outline (build, unit tests, contract tests, integration demo job), developer DX notes for running the local demo and updating recordings, and an acceptance checklist enumerating functional and non‑functional requirements. Provide representative function/type signatures, example config files, and a small example CLI command sequence to run the demo. Acceptance: concrete project layout and module interfaces, comprehensive testing plan including contract/integration tests, CI and local demo instructions, updated acceptance checklist.

/speckit.tasks Break the plan into a prioritized list of granular tasks grouped by milestones: project scaffolding, core library, CLI, testing & CI, demo & docs. For each task include a short title, work description, estimated complexity (S/M/L) with rough time estimate, dependencies, acceptance criteria (pass/fail), and suggested owner/role. Provide 3–5 tasks per milestone, prioritize them, and produce an initial 2‑week sprint backlog (epics → stories → tickets) with the sprint backlog items identified. Acceptance: tasks are granular and actionable, prioritized and assigned to milestones, and an initial 2‑week sprint backlog is identified.